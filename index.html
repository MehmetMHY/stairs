<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Infinite Stairway</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: Arial, sans-serif;
      }
      #game-container {
        position: relative;
        width: 100vw;
        height: 100vh;
        background: linear-gradient(to bottom, #2c1e4a, #5c4a99);
      }
      #counter {
        position: absolute;
        top: 75px;
        left: 0;
        right: 0;
        color: #fff;
        font-size: 100px;
        z-index: 100;
        text-shadow: 0 0 5px #000;
        text-align: center;
        opacity: 0;
        transition: opacity 1s;
      }
      #milestone {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #fff;
        font-size: 48px;
        opacity: 0;
        transition: opacity 1s;
        text-shadow: 0 0 10px #ffc107;
        z-index: 100;
      }
      .instructions {
        position: absolute;
        bottom: 20px;
        left: 0;
        right: 0;
        color: #fff;
        font-size: 16px;
        z-index: 100;
        text-shadow: 0 0 5px #000;
        text-align: center;
        transition: opacity 1s;
      }
      #game-title {
        position: absolute;
        top: 100px;
        left: 0;
        right: 0;
        color: #fff;
        font-size: 120px;
        font-weight: bold;
        z-index: 100;
        text-shadow: 0 0 15px #8a2be2;
        text-align: center;
        letter-spacing: 8px;
        transition: opacity 0s;
      }
    </style>
  </head>
  <body>
    <div id="game-container">
      <div id="game-title">STAIRS</div>
      <div id="counter">0</div>
      <div id="milestone"></div>
      <div id="instructions" class="instructions">
        Use arrow keys or WASD to climb
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      // Game variables
      let currentStep = 0;
      let camera, scene, renderer;
      let player,
        stairs = [];
      let isMoving = false;
      let sun;
      let floatingObjects = [];
      let hasStartedMoving = false;
      let playerLight; // Add a dedicated light for the player

      // Initialize the game
      function init() {
        // Create scene
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0xffb380, 0.03);

        // Create camera
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000,
        );
        camera.position.set(0, 1, 3);
        camera.lookAt(0, 2, 0);

        // Create renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000);
        document
          .getElementById("game-container")
          .appendChild(renderer.domElement);

        // Create lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);

        // Create sun/directional light
        sun = new THREE.DirectionalLight(0xffffff, 1);
        sun.position.set(5, 10, 7);
        scene.add(sun);

        // Create player light that will follow the player - adjusted brightness
        playerLight = new THREE.PointLight(0xffffff, 1.5, 8);
        playerLight.position.set(0, 2, 1);
        scene.add(playerLight);

        // Create a glowing sun sphere
        const sunGeometry = new THREE.SphereGeometry(2, 32, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffee88 });
        const sunSphere = new THREE.Mesh(sunGeometry, sunMaterial);
        sunSphere.position.set(15, 15, -20);
        scene.add(sunSphere);

        // Create player (sphere) - MODIFIED FOR MORE 3D APPEARANCE
        const playerGeometry = new THREE.SphereGeometry(0.3, 32, 32); // Increased segments for smoother appearance

        // Use PhongMaterial instead of BasicMaterial for a more 3D look with lighting effects
        const playerMaterial = new THREE.MeshPhongMaterial({
          color: 0x1a75ff, // Start with blue color
          shininess: 100, // Add shininess for highlight effect
          specular: 0xffffff, // White specular highlights
        });

        player = new THREE.Mesh(playerGeometry, playerMaterial);
        player.position.set(0, 0.4, 0);
        player.castShadow = true; // Enable shadow casting
        scene.add(player);

        // Create ground
        const groundGeometry = new THREE.PlaneGeometry(100, 100);
        const groundMaterial = new THREE.MeshLambertMaterial({
          color: 0x553311,
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.5;
        scene.add(ground);

        // Create initial stairs
        createInitialStairs();

        // Create more initial floating objects
        for (let i = 0; i < 100; i++) {
          createFloatingObject();
        }

        // Add event listeners
        window.addEventListener("resize", onWindowResize);
        document.addEventListener("keydown", onKeyDown);

        // Start animation loop
        animate();
      }

      // Create initial set of stairs
      function createInitialStairs() {
        for (let i = 0; i < 10; i++) {
          createStair(i);
        }
      }

      // Create a new stair
      function createStair(index) {
        const isMilestone = index > 0 && index % 500 === 0;
        const stairGeometry = new THREE.BoxGeometry(1, 0.15, 0.5);

        // Different color for milestone stairs
        const stairMaterial = isMilestone
          ? new THREE.MeshLambertMaterial({ color: 0xffd700 })
          : new THREE.MeshLambertMaterial({ color: 0xcccccc });

        const stair = new THREE.Mesh(stairGeometry, stairMaterial);
        stair.position.set(0, index * 0.2, -index * 0.5);

        // For milestone stairs, create a text marker
        if (isMilestone) {
          // Create invisible marker for milestone reference
          stair.userData.isMilestone = true;
          stair.userData.milestoneNumber = index;
        }

        scene.add(stair);
        stairs.push(stair);

        // Remove old stairs when we have too many
        if (stairs.length > 30) {
          const oldStair = stairs.shift();
          scene.remove(oldStair);
          oldStair.geometry.dispose();
          oldStair.material.dispose();
        }
      }

      // Create a floating object
      function createFloatingObject() {
        // Random shape selection
        const shapes = [
          new THREE.SphereGeometry(Math.random() * 0.5 + 0.2, 8, 8),
          new THREE.BoxGeometry(
            Math.random() * 0.5 + 0.2,
            Math.random() * 0.5 + 0.2,
            Math.random() * 0.5 + 0.2,
          ),
          new THREE.TorusGeometry(
            Math.random() * 0.3 + 0.1,
            Math.random() * 0.1 + 0.05,
            8,
            16,
          ),
          new THREE.TetrahedronGeometry(Math.random() * 0.4 + 0.2),
          new THREE.OctahedronGeometry(Math.random() * 0.4 + 0.1),
        ];

        const geometry = shapes[Math.floor(Math.random() * shapes.length)];

        // Generate a vibrant color
        const colors = [
          0xff5555, 0x55ff55, 0x5555ff, 0xffff55, 0xff55ff, 0x55ffff, 0xff8855,
          0xff55aa, 0x88ff55,
        ];
        const color = colors[Math.floor(Math.random() * colors.length)];

        // Material - either basic or phong with glow
        let material;
        if (Math.random() > 0.5) {
          material = new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.6 + Math.random() * 0.4,
          });
        } else {
          material = new THREE.MeshPhongMaterial({
            color: color,
            transparent: true,
            opacity: 0.7 + Math.random() * 0.3,
            shininess: 90,
            emissive: color,
            emissiveIntensity: 0.2,
          });
        }

        const object = new THREE.Mesh(geometry, material);

        // Position relative to current player height
        const heightOffset = Math.random() * 30 - 10; // -10 to +20 relative to player
        const maxRadius = 15;
        const minRadius = 3;
        const radius = Math.random() * (maxRadius - minRadius) + minRadius;
        const angle = Math.random() * Math.PI * 2;

        object.position.x = Math.sin(angle) * radius;
        object.position.y = currentStep * 0.2 + heightOffset;
        object.position.z = Math.cos(angle) * radius - currentStep * 0.5;

        // Add random rotation
        object.rotation.x = Math.random() * Math.PI * 2;
        object.rotation.y = Math.random() * Math.PI * 2;
        object.rotation.z = Math.random() * Math.PI * 2;

        // Add movement properties
        object.userData.rotSpeed = {
          x: (Math.random() - 0.5) * 0.03,
          y: (Math.random() - 0.5) * 0.03,
          z: (Math.random() - 0.5) * 0.03,
        };

        object.userData.moveSpeed = {
          x: (Math.random() - 0.5) * 0.05,
          y: (Math.random() - 0.5) * 0.02,
          z: (Math.random() - 0.5) * 0.05,
        };

        // Add pulsing effect
        object.userData.pulseSpeed = Math.random() * 0.05 + 0.02;
        object.userData.pulseSize = Math.random() * 0.2 + 0.1;
        object.userData.originalScale = object.scale.clone();
        object.userData.pulseOffset = Math.random() * Math.PI * 2;

        scene.add(object);
        floatingObjects.push(object);

        // Limit the number of floating objects to prevent performance issues
        if (floatingObjects.length > 300) {
          const oldObject = floatingObjects.shift();
          scene.remove(oldObject);
          oldObject.geometry.dispose();
          oldObject.material.dispose();
        }
      }

      // Handle window resize
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // Handle keyboard input
      function onKeyDown(event) {
        if (isMoving) return;

        if (event.key === "ArrowUp" || event.key === "w" || event.key === "W") {
          if (!hasStartedMoving) {
            hasStartedMoving = true;
            // Hide title and show game UI
            document.getElementById("game-title").style.display = "none";
            document.getElementById("counter").style.opacity = 1;
            // Hide instructions
            document.getElementById("instructions").style.opacity = 0;
          }
          moveUp();
        }
      }

      // Generate random color for player
      function getRandomColor() {
        const colors = [
          0xff5555, 0x55ff55, 0x5555ff, 0xffff55, 0xff55ff, 0x55ffff, 0xff8855,
          0xff55aa, 0x88ff55, 0xaa5555, 0x55aa55, 0x5555aa, 0xaaaa55, 0xaa55aa,
          0x55aaaa,
        ];
        return colors[Math.floor(Math.random() * colors.length)];
      }

      // Move player up the stairs
      function moveUp() {
        if (isMoving) return;
        
        isMoving = true;

        currentStep++;
        document.getElementById("counter").textContent = `${currentStep}`;

        // MODIFIED: Change player color every 100 steps instead of every step
        if (currentStep % 100 === 0) {
          player.material.color.setHex(getRandomColor());

          // Show a small notification for color change
          const milestoneDiv = document.getElementById("milestone");
          milestoneDiv.textContent = `${currentStep}`;
          milestoneDiv.style.opacity = 0.7;

          setTimeout(() => {
            milestoneDiv.style.opacity = 0;
          }, 1500);
        }

        // Create new stairs as needed
        createStair(currentStep + 9);

        // Create new floating objects as we climb
        for (let i = 0; i < 5; i++) {
          createFloatingObject();
        }

        // Animate the movement
        const targetY = player.position.y + 0.2;
        const targetZ = player.position.z - 0.5;

        // Check if we're reaching a milestone
        if (currentStep % 500 === 0) {
          showMilestone(currentStep);
        }

        // Smooth animation
        const startY = player.position.y;
        const startZ = player.position.z;
        const startCameraY = camera.position.y;
        const startCameraZ = camera.position.z;
        const duration = 200; // ms
        const startTime = Date.now();

        function step() {
          const elapsed = Date.now() - startTime;
          const progress = Math.min(elapsed / duration, 1);

          player.position.y = startY + (targetY - startY) * progress;
          player.position.z = startZ + (targetZ - startZ) * progress;

          camera.position.y = startCameraY + 0.2 * progress;
          camera.position.z = startCameraZ - 0.5 * progress;
          camera.lookAt(
            player.position.x,
            player.position.y + 0.5,
            player.position.z - 2,
          );

          // Update player light position to follow the player
          updatePlayerLight();

          if (progress < 1) {
            requestAnimationFrame(step);
          } else {
            isMoving = false;
          }
        }

        requestAnimationFrame(step);
      }

      // Update player light to follow the player
      function updatePlayerLight() {
        // Position the light slightly above and in front of the player
        playerLight.position.set(
          player.position.x,
          player.position.y + 0.8, // Positioned slightly above the player
          player.position.z + 0.5, // Positioned slightly in front of the player
        );
      }

      // Show milestone message
      function showMilestone(step) {
        const milestoneDiv = document.getElementById("milestone");
        milestoneDiv.textContent = `${step} STEPS`;
        milestoneDiv.style.opacity = 1;

        setTimeout(() => {
          milestoneDiv.style.opacity = 0;
        }, 3000);
      }

      // Update floating objects
      function updateFloatingObjects() {
        const time = Date.now() * 0.001;

        floatingObjects.forEach((object, index) => {
          // Apply rotation
          object.rotation.x += object.userData.rotSpeed.x;
          object.rotation.y += object.userData.rotSpeed.y;
          object.rotation.z += object.userData.rotSpeed.z;

          // Apply movement
          object.position.x += object.userData.moveSpeed.x;
          object.position.y += object.userData.moveSpeed.y;
          object.position.z += object.userData.moveSpeed.z;

          // Apply pulsing effect
          const pulse =
            Math.sin(
              time * object.userData.pulseSpeed + object.userData.pulseOffset,
            ) *
              object.userData.pulseSize +
            1;
          object.scale.set(
            object.userData.originalScale.x * pulse,
            object.userData.originalScale.y * pulse,
            object.userData.originalScale.z * pulse,
          );

          // Boundary check to keep objects from drifting too far
          const distance = object.position.distanceTo(
            new THREE.Vector3(0, object.position.y, -currentStep * 0.5),
          );
          if (distance > 25) {
            // Gently push back toward center
            object.userData.moveSpeed.x -= object.position.x * 0.0003;
            object.userData.moveSpeed.z -=
              (object.position.z + currentStep * 0.5) * 0.0003;
          }

          // If object is too far behind or below player, reposition it ahead
          if (
            object.position.y < player.position.y - 15 ||
            object.position.z > player.position.z + 15
          ) {
            // Reposition ahead of player
            const heightOffset = Math.random() * 20 - 5;
            const radius = Math.random() * 12 + 3;
            const angle = Math.random() * Math.PI * 2;

            object.position.x = Math.sin(angle) * radius;
            object.position.y = player.position.y + heightOffset;
            object.position.z =
              player.position.z - Math.cos(angle) * radius - 15;

            // Randomize movement again
            object.userData.moveSpeed = {
              x: (Math.random() - 0.5) * 0.05,
              y: (Math.random() - 0.5) * 0.02,
              z: (Math.random() - 0.5) * 0.05,
            };
          }
        });
      }

      // Change sky color based on height
      function updateSkyColor() {
        const cyclePeriod = 2000; // Steps for one complete color cycle
        const heightRatio = (currentStep % cyclePeriod) / cyclePeriod;

        // Create a cycling color pattern
        let skyColor;
        if (heightRatio < 0.25) {
          // Deep blue to purple
          skyColor = new THREE.Color().setHSL(
            0.7,
            0.8,
            heightRatio * 2 * 0.3 + 0.1,
          );
        } else if (heightRatio < 0.5) {
          // Purple to orange/red
          skyColor = new THREE.Color().setHSL(
            0.7 - (heightRatio - 0.25) * 4 * 0.6,
            0.8,
            0.2,
          );
        } else if (heightRatio < 0.75) {
          // Orange/red to teal
          skyColor = new THREE.Color().setHSL(
            0.1 + (heightRatio - 0.5) * 4 * 0.4,
            0.8,
            0.2,
          );
        } else {
          // Teal back to deep blue
          skyColor = new THREE.Color().setHSL(
            0.5 + (heightRatio - 0.75) * 4 * 0.2,
            0.8,
            0.2,
          );
        }

        scene.fog.color = skyColor;
        renderer.setClearColor(skyColor);
      }

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);

        // Sun rotation effect (slow)
        sun.position.x = 15 * Math.cos(Date.now() * 0.0001);
        sun.position.z = 15 * Math.sin(Date.now() * 0.0001);

        // Update player light position
        updatePlayerLight();

        // Update floating objects
        updateFloatingObjects();

        // Update sky color based on height
        updateSkyColor();

        // Add additional lighting effects for the player sphere to enhance 3D appearance
        if (player) {
          // Make the player sphere slightly pulsate to enhance 3D effect
          const pulseFactor = 1 + Math.sin(Date.now() * 0.003) * 0.03;
          player.scale.set(pulseFactor, pulseFactor, pulseFactor);
        }

        renderer.render(scene, camera);
      }

      // Start the game
      init();
    </script>
  </body>
</html>
