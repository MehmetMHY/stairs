<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Infinite Stairway</title>
    <link rel="icon" type="image/png" href="./icon.png" />
    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: Arial, sans-serif;
      }
      #game-container {
        position: relative;
        width: 100vw;
        height: 100vh;
        background: linear-gradient(to bottom, #2c1e4a, #5c4a99);
      }
      #counter {
        position: absolute;
        top: 75px;
        left: 0;
        right: 0;
        color: #fff;
        font-size: 100px;
        z-index: 100;
        text-shadow: 0 0 5px #000;
        text-align: center;
        opacity: 0;
        transition:
          opacity 1s,
          text-shadow 0.3s ease-out;
      }
      .counter-glow {
        text-shadow:
          0 0 25px #ffc107,
          0 0 10px #fff; /* Glowing effect */
      }
      #milestone {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #fff;
        font-size: 48px;
        opacity: 0;
        transition: opacity 1s;
        text-shadow: 0 0 10px #ffc107;
        z-index: 100;
      }
      .instructions {
        position: absolute;
        bottom: 20px;
        left: 20px; /* Positioned to the left */
        color: #fff;
        font-size: 16px;
        z-index: 100;
        text-shadow: 0 0 5px #000;
        text-align: left; /* Aligned to the left */
        transition: opacity 1s;
      }
      #game-title {
        position: absolute;
        top: 100px;
        left: 0;
        right: 0;
        color: #fff;
        font-size: clamp(
          64px,
          22.4vw,
          320px
        ); /* Adjusted clamp for larger size */
        font-weight: bold;
        z-index: 100;
        text-shadow: 0 0 15px #8a2be2;
        text-align: center;
        letter-spacing: 8px;
        transition: opacity 0s;
      }
      #game-over {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #e74c3c;
        font-size: 80px;
        font-weight: bold;
        text-shadow: 0 0 15px #c0392b;
        z-index: 100;
        text-align: center;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.5s;
      }
      #restart-message {
        position: absolute;
        top: 60%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #fff;
        font-size: 24px;
        text-shadow: 0 0 5px #000;
        z-index: 100;
        text-align: center;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.5s;
      }
      #header-controls {
        position: absolute;
        top: 20px;
        right: 20px;
        z-index: 110; /* Ensure it's above other elements */
        display: flex;
        gap: 10px;
      }
      .control-button {
        padding: 8px 15px;
        font-size: 14px;
        color: #fff;
        background-color: rgba(0, 0, 0, 0.4);
        border: 1px solid rgba(255, 255, 255, 0.5);
        border-radius: 5px;
        cursor: pointer;
        text-decoration: none; /* For the link button */
        transition:
          background-color 0.2s,
          border-color 0.2s;
      }
      .control-button:hover {
        background-color: rgba(0, 0, 0, 0.6);
        border-color: #fff;
      }
    </style>
  </head>
  <body>
    <div id="game-container">
      <div id="header-controls">
        <button id="mute-button" class="control-button">Mute</button>
        <button id="restart-button" class="control-button">Restart</button>
        <a
          href="https://github.com/MehmetMHY/stairs"
          target="_blank"
          id="code-button"
          class="control-button"
          >Code</a
        >
      </div>
      <div id="game-title">STAIRS</div>
      <div id="counter">0</div>
      <div id="milestone"></div>
      <div id="instructions" class="instructions">
        Hit up arrow, w key, or tap the screen to climb!
      </div>
      <div id="game-over">GAME OVER</div>
      <div id="restart-message">Press SPACE to restart</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      // Game variables
      let currentStep = 0;
      let camera, scene, renderer;
      let player,
        stairs = [];
      let isMoving = false;
      let sun;
      let floatingObjects = [];
      let hasStartedMoving = false;
      let playerLight; // Add a dedicated light for the player
      let isGameOver = false;
      let animationId = null; // Store animation frame ID
      let fallSpeed = 0; // Player fall speed
      let isFalling = false; // Track if player is falling
      let lastStairWasMoving = false; // Track if the previous stair was moving
      let backgroundMusic = null; // Variable for background music
      let musicPlaying = false; // Track if music is currently intended to play

      // Handle keyboard input
      function onKeyDown(event) {
        if (isGameOver) {
          // If game over, only allow restart
          if (event.code === "Space") {
            window.location.reload(); // Force complete page reload
            return;
          }
        }

        if (isMoving || isFalling) return;

        if (event.key === "ArrowUp" || event.key === "w" || event.key === "W") {
          if (!hasStartedMoving) {
            hasStartedMoving = true;
            // Hide title and show game UI
            document.getElementById("game-title").style.display = "none";
            document.getElementById("counter").style.opacity = 1;
            // Hide instructions
            document.getElementById("instructions").style.opacity = 0;

            // Attempt to play background music again on first interaction (if not already playing)
            if (backgroundMusic && !musicPlaying) {
              try {
                backgroundMusic.play();
                musicPlaying = true;
                console.log("Background music started via interaction.");
              } catch (error) {
                console.error(
                  "Could not play background music via interaction:",
                  error,
                );
                musicPlaying = false; // Ensure flag is correct if play fails
              }
            }
          }
          moveUp();
        }
      }

      // Initialize the game
      function init() {
        // Reset game state
        isGameOver = false;
        currentStep = 0;
        stairs = [];
        floatingObjects = [];
        hasStartedMoving = false;
        isFalling = false;
        fallSpeed = 0;
        lastStairWasMoving = false;
        musicPlaying = false; // Reset music playing state

        // Cancel any existing animation frame
        if (animationId !== null) {
          cancelAnimationFrame(animationId);
        }

        // Hide game over UI
        document.getElementById("game-over").style.opacity = "0";
        document.getElementById("restart-message").style.opacity = "0";

        // Show instructions and title if starting fresh
        document.getElementById("instructions").style.opacity = "1";
        document.getElementById("game-title").style.display = "block";
        document.getElementById("counter").style.opacity = "0";
        document.getElementById("counter").textContent = "0";
        document.getElementById("counter").classList.remove("counter-glow"); // Ensure glow is off on reset

        // Create scene
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0xffb380, 0.03);

        // Create camera
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000,
        );
        camera.position.set(0, 1, 3);
        camera.lookAt(0, 2, 0);

        // Create renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000);

        // Clear previous canvas if exists
        const container = document.getElementById("game-container");
        if (container.querySelector("canvas")) {
          container.removeChild(container.querySelector("canvas"));
        }
        container.appendChild(renderer.domElement);

        // Create lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);

        // Create sun/directional light
        sun = new THREE.DirectionalLight(0xffffff, 1);
        sun.position.set(5, 10, 7);
        scene.add(sun);

        // Create player light that will follow the player - adjusted brightness
        playerLight = new THREE.PointLight(0xffffff, 1.5, 8);
        playerLight.position.set(0, 2, 1);
        scene.add(playerLight);

        // Create a glowing sun sphere
        const sunGeometry = new THREE.SphereGeometry(2, 32, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffee88 });
        const sunSphere = new THREE.Mesh(sunGeometry, sunMaterial);
        sunSphere.position.set(15, 15, -20);
        scene.add(sunSphere);

        // Create player (sphere) - MODIFIED FOR MORE 3D APPEARANCE
        const playerGeometry = new THREE.SphereGeometry(0.3, 32, 32); // Increased segments for smoother appearance

        // Use PhongMaterial instead of BasicMaterial for a more 3D look with lighting effects
        const playerMaterial = new THREE.MeshPhongMaterial({
          color: 0x1a75ff, // Start with blue color
          shininess: 100, // Add shininess for highlight effect
          specular: 0xffffff, // White specular highlights
        });

        player = new THREE.Mesh(playerGeometry, playerMaterial);
        player.position.set(0, 0.4, 0); // Start position for step 0
        player.castShadow = true; // Enable shadow casting
        scene.add(player);

        // Create ground
        const groundGeometry = new THREE.PlaneGeometry(100, 100);
        const groundMaterial = new THREE.MeshLambertMaterial({
          color: 0x553311,
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.5;
        scene.add(ground);

        // Create initial stairs
        createInitialStairs();

        // Create more initial floating objects (Reverted to original amount)
        for (let i = 0; i < 100; i++) {
          createFloatingObject();
        }

        // Initialize background music
        try {
          backgroundMusic = new Audio("./music.mp3");
          backgroundMusic.loop = true;
          // Attempt to play music immediately (might be blocked by browser)
          backgroundMusic
            .play()
            .then(() => {
              musicPlaying = true;
              console.log("Background music started automatically.");
            })
            .catch((error) => {
              console.log("Autoplay blocked, waiting for user interaction.");
              // Music will be played on first key press
            });
        } catch (error) {
          console.error("Error initializing background music:", error);
          backgroundMusic = null; // Ensure it's null if initialization failed
        }

        // Add event listeners
        window.addEventListener("resize", onWindowResize);
        document.addEventListener("keydown", onKeyDown);
        document
          .getElementById("game-container")
          .addEventListener("touchstart", onTouchStart); // Add touch listener

        // Header controls event listeners
        const muteButton = document.getElementById("mute-button");
        if (muteButton && backgroundMusic) {
          muteButton.addEventListener("click", () => {
            backgroundMusic.muted = !backgroundMusic.muted;
            muteButton.textContent = backgroundMusic.muted ? "Unmute" : "Mute";
            // Save state to localStorage
            localStorage.setItem(
              "isMuted",
              backgroundMusic.muted ? "true" : "false",
            );
          });
        }

        const restartButton = document.getElementById("restart-button");
        if (restartButton) {
          restartButton.addEventListener("click", () => {
            window.location.reload();
          });
        }

        // Apply stored mute state
        const storedMuteState = localStorage.getItem("isMuted");
        if (backgroundMusic) {
          if (storedMuteState === "true") {
            backgroundMusic.muted = true;
            muteButton.textContent = "Unmute";
          } else {
            backgroundMusic.muted = false;
            muteButton.textContent = "Mute";
          }
        }

        // Start animation loop
        animate();
      }

      // Handle touch input for mobile
      function onTouchStart(event) {
        // Check if the touch target is inside the header controls
        const targetElement = event.target;
        if (
          targetElement.classList.contains("control-button") ||
          targetElement.closest("#header-controls")
        ) {
          // Allow default behavior for buttons (click/navigation)
          return;
        }

        // Prevent default touch behavior like scrolling *only if* not a control
        event.preventDefault();

        if (isGameOver) {
          // Optional: Could trigger reload on tap when game over
          // window.location.reload();
          return;
        }

        if (isMoving || isFalling) return;

        // Get the Y coordinate of the first touch
        const touchY = event.touches[0].clientY;
        const screenHeight = window.innerHeight;

        // Check if the tap is in the lower half of the screen
        if (touchY > screenHeight / 2) {
          if (!hasStartedMoving) {
            hasStartedMoving = true;
            // Hide title and show game UI
            document.getElementById("game-title").style.display = "none";
            document.getElementById("counter").style.opacity = 1;
            // Hide instructions
            document.getElementById("instructions").style.opacity = 0;

            // Attempt to play background music again on first interaction (if not already playing)
            if (backgroundMusic && !musicPlaying) {
              try {
                backgroundMusic.play();
                musicPlaying = true;
                console.log("Background music started via interaction.");
              } catch (error) {
                console.error(
                  "Could not play background music via interaction:",
                  error,
                );
                musicPlaying = false; // Ensure flag is correct if play fails
              }
            }
          }
          moveUp();
        }
      }

      // Create initial set of stairs
      function createInitialStairs() {
        for (let i = 0; i < 10; i++) {
          createStair(i);
        }
      }

      // Create a new stair
      function createStair(index) {
        const isMilestone = index > 0 && index % 500 === 0;

        // Determine if this stair *could* be moving
        let potentialMoving = index > 5 && Math.random() < 0.3 && !isMilestone;

        // Ensure no consecutive moving stairs
        if (potentialMoving && lastStairWasMoving) {
          potentialMoving = false;
        }

        const isMovingStair = potentialMoving;

        // Determine stair width
        const stairWidth = isMovingStair ? 2 : 1;

        const stairGeometry = new THREE.BoxGeometry(stairWidth, 0.15, 0.5);

        // Different color for different types of stairs
        let stairMaterial;
        if (isMilestone) {
          stairMaterial = new THREE.MeshLambertMaterial({ color: 0xffd700 }); // Gold
        } else if (isMovingStair) {
          stairMaterial = new THREE.MeshPhongMaterial({
            color: 0xff6b6b, // Red
            shininess: 80,
            emissive: 0x992222,
            emissiveIntensity: 0.2,
          });
        } else {
          stairMaterial = new THREE.MeshLambertMaterial({ color: 0xcccccc }); // Regular gray
        }

        const stair = new THREE.Mesh(stairGeometry, stairMaterial);
        stair.position.set(0, index * 0.2, -index * 0.5);

        // For milestone stairs, create a text marker
        if (isMilestone) {
          // Create invisible marker for milestone reference
          stair.userData.isMilestone = true;
          stair.userData.milestoneNumber = index;
        }

        // For moving stairs, add movement properties
        if (isMovingStair) {
          stair.userData.isMoving = true;
          // Speed doubled again (range 0.75 to 1.25)
          stair.userData.moveSpeed =
            (Math.random() * 0.5 + 0.75) * (Math.random() < 0.5 ? 1 : -1);
          stair.userData.moveRange = Math.random() * 2.0 + 1.5; // Range of 1.5 to 3.5 units
          stair.userData.originalX = stair.position.x;
          stair.userData.timeOffset = Math.random() * Math.PI * 2; // Random starting position in the cycle
        }

        // Update tracking for the next stair
        lastStairWasMoving = isMovingStair;

        scene.add(stair);
        stairs.push(stair);

        // Remove old stairs when we have too many
        if (stairs.length > 30) {
          const oldStair = stairs.shift();
          scene.remove(oldStair);
          oldStair.geometry.dispose();
          oldStair.material.dispose();
        }
      }

      // Create a floating object
      function createFloatingObject() {
        // Random shape selection
        const shapes = [
          new THREE.SphereGeometry(Math.random() * 0.5 + 0.2, 8, 8),
          new THREE.BoxGeometry(
            Math.random() * 0.5 + 0.2,
            Math.random() * 0.5 + 0.2,
            Math.random() * 0.5 + 0.2,
          ),
          new THREE.TorusGeometry(
            Math.random() * 0.3 + 0.1,
            Math.random() * 0.1 + 0.05,
            8,
            16,
          ),
          new THREE.TetrahedronGeometry(Math.random() * 0.4 + 0.2),
          new THREE.OctahedronGeometry(Math.random() * 0.4 + 0.1),
        ];

        const geometry = shapes[Math.floor(Math.random() * shapes.length)];

        // Generate a vibrant color
        const colors = [
          0xff5555, 0x55ff55, 0x5555ff, 0xffff55, 0xff55ff, 0x55ffff, 0xff8855,
          0xff55aa, 0x88ff55,
        ];
        const color = colors[Math.floor(Math.random() * colors.length)];

        // Material - either basic or phong with glow
        let material;
        if (Math.random() > 0.5) {
          material = new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.6 + Math.random() * 0.4,
          });
        } else {
          material = new THREE.MeshPhongMaterial({
            color: color,
            transparent: true,
            opacity: 0.7 + Math.random() * 0.3,
            shininess: 90,
            emissive: color,
            emissiveIntensity: 0.2,
          });
        }

        const object = new THREE.Mesh(geometry, material);

        // Position relative to current player height
        const heightOffset = Math.random() * 30 - 10; // -10 to +20 relative to player
        const maxRadius = 15;
        const minRadius = 3;
        const radius = Math.random() * (maxRadius - minRadius) + minRadius;
        const angle = Math.random() * Math.PI * 2;

        object.position.x = Math.sin(angle) * radius;
        object.position.y = currentStep * 0.2 + heightOffset;
        object.position.z = Math.cos(angle) * radius - currentStep * 0.5;

        // Add random rotation
        object.rotation.x = Math.random() * Math.PI * 2;
        object.rotation.y = Math.random() * Math.PI * 2;
        object.rotation.z = Math.random() * Math.PI * 2;

        // Add movement properties
        object.userData.rotSpeed = {
          x: (Math.random() - 0.5) * 0.03,
          y: (Math.random() - 0.5) * 0.03,
          z: (Math.random() - 0.5) * 0.03,
        };

        object.userData.moveSpeed = {
          x: (Math.random() - 0.5) * 0.05,
          y: (Math.random() - 0.5) * 0.02,
          z: (Math.random() - 0.5) * 0.05,
        };

        // Add pulsing effect
        object.userData.pulseSpeed = Math.random() * 0.05 + 0.02;
        object.userData.pulseSize = Math.random() * 0.2 + 0.1;
        object.userData.originalScale = object.scale.clone();
        object.userData.pulseOffset = Math.random() * Math.PI * 2;

        scene.add(object);
        floatingObjects.push(object);

        // Limit the number of floating objects to prevent performance issues
        if (floatingObjects.length > 300) {
          const oldObject = floatingObjects.shift();
          scene.remove(oldObject);
          oldObject.geometry.dispose();
          oldObject.material.dispose();
        }
      }

      // Handle window resize
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // Check if player is supported by a stair
      function checkPlayerSupport() {
        if (isMoving || isGameOver || isFalling) return; // Skip check if moving, falling, or game over

        // Calculate the expected height of the stair the player should be on
        // Player center is 0.4 units above the stair surface
        const expectedStairY = player.position.y - 0.4;
        const playerX = player.position.x;

        let isSupported = false;
        let supportingStair = null;

        // Find the stair closest to the player's expected Y level
        for (const stair of stairs) {
          // Check if this stair is at the right height (within a small threshold)
          if (Math.abs(stair.position.y - expectedStairY) < 0.05) {
            // Check if the player is above this stair horizontally (stair width = 1 or 2)
            const halfWidth = stair.geometry.parameters.width / 2;
            if (Math.abs(playerX - stair.position.x) <= halfWidth) {
              isSupported = true;
              supportingStair = stair; // Store the supporting stair
              break;
            }
          }
        }

        // If player is not supported, start falling
        if (!isSupported) {
          console.log(
            `Falling started at Y: ${player.position.y}, expected stair Y: ${expectedStairY}`,
          );
          startFalling();
        }
      }

      // Start player falling
      function startFalling() {
        if (isFalling || isGameOver) return;

        isFalling = true;
        fallSpeed = 0;
      }

      // Update player falling
      function updateFalling() {
        if (!isFalling) return;

        // Increase fall speed (gravity)
        fallSpeed += 0.01;

        // Move player down
        player.position.y -= fallSpeed;

        // Update camera to follow player
        camera.position.y -= fallSpeed;
        camera.lookAt(
          player.position.x,
          player.position.y + 0.5,
          player.position.z - 2,
        );

        // Update player light position
        updatePlayerLight();

        // If player falls too far below the current step level, trigger game over
        if (player.position.y < currentStep * 0.2 + 0.4 - 3) {
          // Allow falling a bit below current step
          gameOver();
          isFalling = false;
        }
      }

      // Generate random color for player
      function getRandomColor() {
        const colors = [
          0xff5555, 0x55ff55, 0x5555ff, 0xffff55, 0xff55ff, 0x55ffff, 0xff8855,
          0xff55aa, 0x88ff55, 0xaa5555, 0x55aa55, 0x5555aa, 0xaaaa55, 0xaa55aa,
          0x55aaaa,
        ];
        return colors[Math.floor(Math.random() * colors.length)];
      }

      // Trigger game over
      function gameOver() {
        if (isGameOver) return;

        isGameOver = true;
        isFalling = false; // Stop falling logic

        // Show game over UI
        document.getElementById("game-over").style.opacity = "1";
        document.getElementById("restart-message").style.opacity = "1";

        // Change player color to indicate failure
        player.material.color.setHex(0xff0000);

        console.log("Game over triggered! Press SPACE to restart.");
      }

      // Move player up the stairs
      function moveUp() {
        if (isMoving || isGameOver || isFalling) return;

        isMoving = true;

        const previousStep = currentStep;
        currentStep++;
        document.getElementById("counter").textContent = `${currentStep}`;

        // Handle 100 step milestone
        if (currentStep % 100 === 0) {
          player.material.color.setHex(getRandomColor());

          // Apply glow effect to counter
          const counterDiv = document.getElementById("counter");
          counterDiv.classList.add("counter-glow");

          // Remove glow after a short time
          setTimeout(() => {
            counterDiv.classList.remove("counter-glow");
          }, 1500);
        }

        // Create new stairs as needed
        createStair(currentStep + 9);

        // Create new floating objects as we climb (Reverted to original amount)
        for (let i = 0; i < 5; i++) {
          createFloatingObject();
        }

        // Get the next stair we're moving to
        const nextStairY = currentStep * 0.2;
        const nextStair = stairs.find(
          (s) => Math.abs(s.position.y - nextStairY) < 0.01,
        );

        // Check if the stair is a moving stair and if the player will land on it
        if (nextStair && nextStair.userData.isMoving) {
          // Calculate distance between player and stair in X axis
          const distanceX = Math.abs(player.position.x - nextStair.position.x);
          const halfWidth = nextStair.geometry.parameters.width / 2;

          // If player is not aligned with the moving stair, game over
          if (distanceX > halfWidth) {
            console.log(
              `Missed moving stair! Player X: ${player.position.x.toFixed(2)}, Stair X: ${nextStair.position.x.toFixed(2)}, HalfWidth: ${halfWidth.toFixed(2)}, Distance: ${distanceX.toFixed(2)}`,
            );
            // Initiate fall from the missed step height
            player.position.y = currentStep * 0.2 + 0.4;
            startFalling();
            isMoving = false; // Stop the moveUp process
            return;
          }
        }

        // Animate the movement
        const targetY = player.position.y + 0.2;
        const targetZ = player.position.z - 0.5;

        // Check if we're reaching a 500 step milestone (for separate visual cue if needed)
        if (currentStep > 0 && currentStep % 500 === 0) {
          showMajorMilestone(currentStep);
        }

        // Smooth animation
        const startY = player.position.y;
        const startZ = player.position.z;
        const startCameraY = camera.position.y;
        const startCameraZ = camera.position.z;
        const duration = 200; // ms
        const startTime = Date.now();

        function step() {
          if (isGameOver) return; // Stop animation if game over

          const elapsed = Date.now() - startTime;
          const progress = Math.min(elapsed / duration, 1);

          player.position.y = startY + (targetY - startY) * progress;
          player.position.z = startZ + (targetZ - startZ) * progress;

          camera.position.y = startCameraY + 0.2 * progress;
          camera.position.z = startCameraZ - 0.5 * progress;
          camera.lookAt(
            player.position.x,
            player.position.y + 0.5,
            player.position.z - 2,
          );

          // Update player light position to follow the player
          updatePlayerLight();

          if (progress < 1) {
            requestAnimationFrame(step);
          } else {
            isMoving = false;
          }
        }

        requestAnimationFrame(step);
      }

      // Update player light to follow the player
      function updatePlayerLight() {
        // Position the light slightly above and in front of the player
        playerLight.position.set(
          player.position.x,
          player.position.y + 0.8, // Positioned slightly above the player
          player.position.z + 0.5, // Positioned slightly in front of the player
        );
      }

      // Show major milestone message (optional, e.g., for 500 steps)
      function showMajorMilestone(step) {
        // You could potentially reuse the #milestone div here if desired
        // Or create a different effect for larger milestones
        console.log(`Reached major milestone: ${step} steps!`);
      }

      // Update moving stairs
      function updateMovingStairs() {
        const time = Date.now() * 0.001;

        stairs.forEach((stair) => {
          if (stair.userData.isMoving) {
            // Calculate sine wave movement
            const offset =
              Math.sin(
                time * Math.abs(stair.userData.moveSpeed) +
                  stair.userData.timeOffset,
              ) * stair.userData.moveRange;
            stair.position.x = stair.userData.originalX + offset;
          }
        });
      }

      // Update floating objects
      function updateFloatingObjects() {
        const time = Date.now() * 0.001;

        floatingObjects.forEach((object, index) => {
          // Apply rotation
          object.rotation.x += object.userData.rotSpeed.x;
          object.rotation.y += object.userData.rotSpeed.y;
          object.rotation.z += object.userData.rotSpeed.z;

          // Apply movement
          object.position.x += object.userData.moveSpeed.x;
          object.position.y += object.userData.moveSpeed.y;
          object.position.z += object.userData.moveSpeed.z;

          // Apply pulsing effect
          const pulse =
            Math.sin(
              time * object.userData.pulseSpeed + object.userData.pulseOffset,
            ) *
              object.userData.pulseSize +
            1;
          object.scale.set(
            object.userData.originalScale.x * pulse,
            object.userData.originalScale.y * pulse,
            object.userData.originalScale.z * pulse,
          );

          // Boundary check to keep objects from drifting too far
          const distance = object.position.distanceTo(
            new THREE.Vector3(0, object.position.y, -currentStep * 0.5),
          );
          if (distance > 25) {
            // Gently push back toward center
            object.userData.moveSpeed.x -= object.position.x * 0.0003;
            object.userData.moveSpeed.z -=
              (object.position.z + currentStep * 0.5) * 0.0003;
          }

          // If object is too far behind or below player, reposition it ahead
          if (
            object.position.y < player.position.y - 15 ||
            object.position.z > player.position.z + 15
          ) {
            // Reposition ahead of player
            const heightOffset = Math.random() * 20 - 5;
            const radius = Math.random() * 12 + 3;
            const angle = Math.random() * Math.PI * 2;

            object.position.x = Math.sin(angle) * radius;
            object.position.y = player.position.y + heightOffset;
            object.position.z =
              player.position.z - Math.cos(angle) * radius - 15;

            // Randomize movement again
            object.userData.moveSpeed = {
              x: (Math.random() - 0.5) * 0.05,
              y: (Math.random() - 0.5) * 0.02,
              z: (Math.random() - 0.5) * 0.05,
            };
          }
        });
      }

      // Change sky color based on height
      function updateSkyColor() {
        const cyclePeriod = 2000; // Steps for one complete color cycle
        const heightRatio = (currentStep % cyclePeriod) / cyclePeriod;

        // Create a cycling color pattern
        let skyColor;
        if (heightRatio < 0.25) {
          // Deep blue to purple
          skyColor = new THREE.Color().setHSL(
            0.7,
            0.8,
            heightRatio * 2 * 0.3 + 0.1,
          );
        } else if (heightRatio < 0.5) {
          // Purple to orange/red
          skyColor = new THREE.Color().setHSL(
            0.7 - (heightRatio - 0.25) * 4 * 0.6,
            0.8,
            0.2,
          );
        } else if (heightRatio < 0.75) {
          // Orange/red to teal
          skyColor = new THREE.Color().setHSL(
            0.1 + (heightRatio - 0.5) * 4 * 0.4,
            0.8,
            0.2,
          );
        } else {
          // Teal back to deep blue
          skyColor = new THREE.Color().setHSL(
            0.5 + (heightRatio - 0.75) * 4 * 0.2,
            0.8,
            0.2,
          );
        }

        scene.fog.color = skyColor;
        renderer.setClearColor(skyColor);
      }

      // Animation loop
      function animate() {
        animationId = requestAnimationFrame(animate);

        // Sun rotation effect (slow)
        sun.position.x = 15 * Math.cos(Date.now() * 0.0001);
        sun.position.z = 15 * Math.sin(Date.now() * 0.0001);

        // Update moving stairs
        updateMovingStairs();

        // Check if player is supported by a stair
        checkPlayerSupport();

        // Update falling if player is falling
        updateFalling();

        // Update player light position
        updatePlayerLight();

        // Update floating objects
        updateFloatingObjects();

        // Update sky color based on height
        updateSkyColor();

        // Add additional lighting effects for the player sphere to enhance 3D appearance
        if (player) {
          // Make the player sphere slightly pulsate to enhance 3D effect
          const pulseFactor = 1 + Math.sin(Date.now() * 0.003) * 0.03;
          player.scale.set(pulseFactor, pulseFactor, pulseFactor);
        }

        renderer.render(scene, camera);
      }

      // Start the game
      init();
    </script>
  </body>
</html>
