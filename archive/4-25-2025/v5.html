<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Infinite Stairway</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: Arial, sans-serif;
      }
      #game-container {
        position: relative;
        width: 100vw;
        height: 100vh;
        background: linear-gradient(to bottom, #2c1e4a, #5c4a99);
      }
      #counter {
        position: absolute;
        top: 20px;
        left: 0;
        right: 0;
        color: #fff;
        font-size: 32px;
        z-index: 100;
        text-shadow: 0 0 5px #000;
        text-align: center;
      }
      #milestone {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #fff;
        font-size: 48px;
        opacity: 0;
        transition: opacity 1s;
        text-shadow: 0 0 10px #ffc107;
        z-index: 100;
      }
      .instructions {
        position: absolute;
        bottom: 20px;
        left: 0;
        right: 0;
        color: #fff;
        font-size: 16px;
        z-index: 100;
        text-shadow: 0 0 5px #000;
        text-align: center;
        transition: opacity 1s;
      }
      #day-indicator {
        position: absolute;
        top: 60px;
        left: 0;
        right: 0;
        color: #fff;
        font-size: 18px;
        z-index: 100;
        text-shadow: 0 0 5px #000;
        text-align: center;
      }
    </style>
  </head>
  <body>
    <div id="game-container">
      <div id="counter">Steps: 0</div>
      <div id="day-indicator">Dawn</div>
      <div id="milestone"></div>
      <div id="instructions" class="instructions">
        Use arrow keys or WASD to climb
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      // Game variables
      let currentStep = 0;
      let camera, scene, renderer;
      let player,
        stairs = [];
      let isMoving = false;
      let sun, moon;
      let floatingObjects = [];
      let hasStartedMoving = false;

      // Day-night cycle
      const DAY_LENGTH = 1000; // Steps for one complete day
      let dayTime = 0; // 0-1 representing time of day
      let stars = [];

      // Time of day names
      const timeNames = [
        { max: 0.2, name: "Dawn" },
        { max: 0.4, name: "Morning" },
        { max: 0.6, name: "Midday" },
        { max: 0.8, name: "Sunset" },
        { max: 1.0, name: "Night" },
      ];

      // Initialize the game
      function init() {
        // Create scene
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0xffb380, 0.03);

        // Create camera
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000,
        );
        camera.position.set(0, 1, 3);
        camera.lookAt(0, 2, 0);

        // Create renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000);
        document
          .getElementById("game-container")
          .appendChild(renderer.domElement);

        // Create lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);

        // Create sun/directional light
        sun = new THREE.DirectionalLight(0xffffff, 1);
        sun.position.set(5, 10, 7);
        scene.add(sun);

        // Create moon light (dimmer, blueish)
        moon = new THREE.DirectionalLight(0x8888ff, 0.3);
        moon.position.set(-5, 10, 7);
        scene.add(moon);

        // Add a point light to illuminate the player
        const pointLight = new THREE.PointLight(0xffffff, 0.8, 5);
        pointLight.position.set(0, 2, 1);
        scene.add(pointLight);

        // Create a glowing sun sphere
        const sunGeometry = new THREE.SphereGeometry(2, 32, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffee88 });
        const sunSphere = new THREE.Mesh(sunGeometry, sunMaterial);
        sunSphere.position.set(15, 15, -20);
        scene.add(sunSphere);
        sun.userData = { sphere: sunSphere };

        // Create moon sphere
        const moonGeometry = new THREE.SphereGeometry(1.5, 32, 32);
        const moonMaterial = new THREE.MeshBasicMaterial({ color: 0xddddff });
        const moonSphere = new THREE.Mesh(moonGeometry, moonMaterial);
        moonSphere.position.set(-15, 15, -20);
        scene.add(moonSphere);
        moon.userData = { sphere: moonSphere };

        // Create stars
        createStars();

        // Create player (sphere) with improved 3D appearance
        const playerGeometry = new THREE.SphereGeometry(0.3, 32, 32);

        // Use PhongMaterial instead of BasicMaterial for a more 3D look with lighting effects
        const playerMaterial = new THREE.MeshPhongMaterial({
          color: 0x1a75ff,
          shininess: 100,
          specular: 0xffffff,
        });

        player = new THREE.Mesh(playerGeometry, playerMaterial);
        player.position.set(0, 0.4, 0);
        player.castShadow = true;
        scene.add(player);

        // Create ground
        const groundGeometry = new THREE.PlaneGeometry(100, 100);
        const groundMaterial = new THREE.MeshLambertMaterial({
          color: 0x553311,
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.5;
        scene.add(ground);

        // Create initial stairs
        createInitialStairs();

        // Create more initial floating objects
        for (let i = 0; i < 100; i++) {
          createFloatingObject();
        }

        // Add event listeners
        window.addEventListener("resize", onWindowResize);
        document.addEventListener("keydown", onKeyDown);

        // Start animation loop
        animate();
      }

      // Create stars for nighttime
      function createStars() {
        const starGeometry = new THREE.BufferGeometry();
        const starMaterial = new THREE.PointsMaterial({
          color: 0xffffff,
          size: 0.1,
          transparent: true,
          opacity: 0, // Start invisible
        });

        const starVertices = [];

        // Create 1000 stars in a dome shape above and around the scene
        for (let i = 0; i < 1000; i++) {
          const radius = 50 + Math.random() * 50;
          // Distribute more stars above than below
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.random() * Math.PI * 0.6; // Only in the top hemisphere

          const x = radius * Math.sin(phi) * Math.cos(theta);
          const y = radius * Math.cos(phi) + 20; // Position above the scene
          const z = radius * Math.sin(phi) * Math.sin(theta) - 20; // Move back a bit

          starVertices.push(x, y, z);
        }

        starGeometry.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(starVertices, 3),
        );
        const starField = new THREE.Points(starGeometry, starMaterial);
        scene.add(starField);
        stars.push(starField);
      }

      // Create initial set of stairs
      function createInitialStairs() {
        for (let i = 0; i < 10; i++) {
          createStair(i);
        }
      }

      // Create a new stair
      function createStair(index) {
        const isMilestone = index > 0 && index % 500 === 0;
        const stairGeometry = new THREE.BoxGeometry(1, 0.15, 0.5);

        // Different color for milestone stairs
        const stairMaterial = isMilestone
          ? new THREE.MeshLambertMaterial({ color: 0xffd700 })
          : new THREE.MeshLambertMaterial({ color: 0xcccccc });

        const stair = new THREE.Mesh(stairGeometry, stairMaterial);
        stair.position.set(0, index * 0.2, -index * 0.5);

        // For milestone stairs, create a text marker
        if (isMilestone) {
          // Create invisible marker for milestone reference
          stair.userData.isMilestone = true;
          stair.userData.milestoneNumber = index;
        }

        scene.add(stair);
        stairs.push(stair);

        // Remove old stairs when we have too many
        if (stairs.length > 30) {
          const oldStair = stairs.shift();
          scene.remove(oldStair);
          oldStair.geometry.dispose();
          oldStair.material.dispose();
        }
      }

      // Create a floating object
      function createFloatingObject() {
        // Random shape selection
        const shapes = [
          new THREE.SphereGeometry(Math.random() * 0.5 + 0.2, 8, 8),
          new THREE.BoxGeometry(
            Math.random() * 0.5 + 0.2,
            Math.random() * 0.5 + 0.2,
            Math.random() * 0.5 + 0.2,
          ),
          new THREE.TorusGeometry(
            Math.random() * 0.3 + 0.1,
            Math.random() * 0.1 + 0.05,
            8,
            16,
          ),
          new THREE.TetrahedronGeometry(Math.random() * 0.4 + 0.2),
          new THREE.OctahedronGeometry(Math.random() * 0.4 + 0.1),
        ];

        const geometry = shapes[Math.floor(Math.random() * shapes.length)];

        // Generate a vibrant color
        const colors = [
          0xff5555, 0x55ff55, 0x5555ff, 0xffff55, 0xff55ff, 0x55ffff, 0xff8855,
          0xff55aa, 0x88ff55,
        ];
        const color = colors[Math.floor(Math.random() * colors.length)];

        // Material - either basic or phong with glow
        let material;
        if (Math.random() > 0.5) {
          material = new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.6 + Math.random() * 0.4,
          });
        } else {
          material = new THREE.MeshPhongMaterial({
            color: color,
            transparent: true,
            opacity: 0.7 + Math.random() * 0.3,
            shininess: 90,
            emissive: color,
            emissiveIntensity: 0.2,
          });
        }

        const object = new THREE.Mesh(geometry, material);

        // Position relative to current player height
        const heightOffset = Math.random() * 30 - 10; // -10 to +20 relative to player
        const maxRadius = 15;
        const minRadius = 3;
        const radius = Math.random() * (maxRadius - minRadius) + minRadius;
        const angle = Math.random() * Math.PI * 2;

        object.position.x = Math.sin(angle) * radius;
        object.position.y = currentStep * 0.2 + heightOffset;
        object.position.z = Math.cos(angle) * radius - currentStep * 0.5;

        // Add random rotation
        object.rotation.x = Math.random() * Math.PI * 2;
        object.rotation.y = Math.random() * Math.PI * 2;
        object.rotation.z = Math.random() * Math.PI * 2;

        // Add movement properties
        object.userData.rotSpeed = {
          x: (Math.random() - 0.5) * 0.03,
          y: (Math.random() - 0.5) * 0.03,
          z: (Math.random() - 0.5) * 0.03,
        };

        object.userData.moveSpeed = {
          x: (Math.random() - 0.5) * 0.05,
          y: (Math.random() - 0.5) * 0.02,
          z: (Math.random() - 0.5) * 0.05,
        };

        // Add pulsing effect
        object.userData.pulseSpeed = Math.random() * 0.05 + 0.02;
        object.userData.pulseSize = Math.random() * 0.2 + 0.1;
        object.userData.originalScale = object.scale.clone();
        object.userData.pulseOffset = Math.random() * Math.PI * 2;

        scene.add(object);
        floatingObjects.push(object);

        // Limit the number of floating objects to prevent performance issues
        if (floatingObjects.length > 300) {
          const oldObject = floatingObjects.shift();
          scene.remove(oldObject);
          oldObject.geometry.dispose();
          oldObject.material.dispose();
        }
      }

      // Handle window resize
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // Handle keyboard input
      function onKeyDown(event) {
        if (isMoving) return;

        if (event.key === "ArrowUp" || event.key === "w" || event.key === "W") {
          if (!hasStartedMoving) {
            hasStartedMoving = true;
            // Hide instructions
            document.getElementById("instructions").style.opacity = 0;
          }
          moveUp();
        }
      }

      // Generate random color for player
      function getRandomColor() {
        const colors = [
          0xff5555, 0x55ff55, 0x5555ff, 0xffff55, 0xff55ff, 0x55ffff, 0xff8855,
          0xff55aa, 0x88ff55, 0xaa5555, 0x55aa55, 0x5555aa, 0xaaaa55, 0xaa55aa,
          0x55aaaa,
        ];
        return colors[Math.floor(Math.random() * colors.length)];
      }

      // Move player up the stairs
      function moveUp() {
        if (isMoving) return;
        isMoving = true;

        currentStep++;
        document.getElementById("counter").textContent =
          `Steps: ${currentStep}`;

        // Update day time
        updateDayTime();

        // Change player color every 100 steps
        if (currentStep % 100 === 0) {
          player.material.color.setHex(getRandomColor());
        }

        // Create new stairs as needed
        createStair(currentStep + 9);

        // Create new floating objects as we climb
        for (let i = 0; i < 5; i++) {
          createFloatingObject();
        }

        // Animate the movement
        const targetY = player.position.y + 0.2;
        const targetZ = player.position.z - 0.5;

        // Check if we're reaching a milestone
        if (currentStep % 500 === 0) {
          showMilestone(currentStep);
        }

        // Smooth animation
        const startY = player.position.y;
        const startZ = player.position.z;
        const startCameraY = camera.position.y;
        const startCameraZ = camera.position.z;
        const duration = 200; // ms
        const startTime = Date.now();

        function step() {
          const elapsed = Date.now() - startTime;
          const progress = Math.min(elapsed / duration, 1);

          player.position.y = startY + (targetY - startY) * progress;
          player.position.z = startZ + (targetZ - startZ) * progress;

          camera.position.y = startCameraY + 0.2 * progress;
          camera.position.z = startCameraZ - 0.5 * progress;
          camera.lookAt(
            player.position.x,
            player.position.y + 0.5,
            player.position.z - 2,
          );

          if (progress < 1) {
            requestAnimationFrame(step);
          } else {
            isMoving = false;
          }
        }

        requestAnimationFrame(step);
      }

      // Update day time based on steps
      function updateDayTime() {
        // Calculate time of day (0-1)
        dayTime = (currentStep % DAY_LENGTH) / DAY_LENGTH;

        // Update day indicator text
        let timeOfDay = "Dawn";
        for (const time of timeNames) {
          if (dayTime <= time.max) {
            timeOfDay = time.name;
            break;
          }
        }
        document.getElementById("day-indicator").textContent = timeOfDay;
      }

      // Show milestone message
      function showMilestone(step) {
        const milestoneDiv = document.getElementById("milestone");
        milestoneDiv.textContent = `${step} STEPS`;
        milestoneDiv.style.opacity = 1;

        setTimeout(() => {
          milestoneDiv.style.opacity = 0;
        }, 3000);
      }

      // Update floating objects
      function updateFloatingObjects() {
        const time = Date.now() * 0.001;

        floatingObjects.forEach((object, index) => {
          // Apply rotation
          object.rotation.x += object.userData.rotSpeed.x;
          object.rotation.y += object.userData.rotSpeed.y;
          object.rotation.z += object.userData.rotSpeed.z;

          // Apply movement
          object.position.x += object.userData.moveSpeed.x;
          object.position.y += object.userData.moveSpeed.y;
          object.position.z += object.userData.moveSpeed.z;

          // Apply pulsing effect
          const pulse =
            Math.sin(
              time * object.userData.pulseSpeed + object.userData.pulseOffset,
            ) *
              object.userData.pulseSize +
            1;
          object.scale.set(
            object.userData.originalScale.x * pulse,
            object.userData.originalScale.y * pulse,
            object.userData.originalScale.z * pulse,
          );

          // Boundary check to keep objects from drifting too far
          const distance = object.position.distanceTo(
            new THREE.Vector3(0, object.position.y, -currentStep * 0.5),
          );
          if (distance > 25) {
            // Gently push back toward center
            object.userData.moveSpeed.x -= object.position.x * 0.0003;
            object.userData.moveSpeed.z -=
              (object.position.z + currentStep * 0.5) * 0.0003;
          }

          // If object is too far behind or below player, reposition it ahead
          if (
            object.position.y < player.position.y - 15 ||
            object.position.z > player.position.z + 15
          ) {
            // Reposition ahead of player
            const heightOffset = Math.random() * 20 - 5;
            const radius = Math.random() * 12 + 3;
            const angle = Math.random() * Math.PI * 2;

            object.position.x = Math.sin(angle) * radius;
            object.position.y = player.position.y + heightOffset;
            object.position.z =
              player.position.z - Math.cos(angle) * radius - 15;

            // Randomize movement again
            object.userData.moveSpeed = {
              x: (Math.random() - 0.5) * 0.05,
              y: (Math.random() - 0.5) * 0.02,
              z: (Math.random() - 0.5) * 0.05,
            };
          }
        });
      }

      // Update the day-night cycle
      function updateDayNightCycle() {
        // Sun arc is 0-0.5 of day time, moon arc is 0.5-1.0
        // Calculate sun position
        let sunHeight, sunBrightness, moonHeight, moonBrightness;

        // Sun rises at 0, peaks at 0.25, sets at 0.5
        if (dayTime < 0.5) {
          // Use sin function to create an arc
          const sunAngle = (dayTime / 0.5) * Math.PI;
          sunHeight = Math.sin(sunAngle) * 20;

          // Sun brightness gradually increases, peaks, then decreases
          sunBrightness = Math.sin(sunAngle);

          // Sun is below horizon at night (slightly negative y)
          moonHeight = -5;
          moonBrightness = 0;
        } else {
          // Moon rises at 0.5, peaks at 0.75, sets at 1.0
          const moonAngle = ((dayTime - 0.5) / 0.5) * Math.PI;
          moonHeight = Math.sin(moonAngle) * 15;

          // Moon brightness isn't as bright as the sun
          moonBrightness = Math.sin(moonAngle) * 0.3;

          // Sun is below horizon during night
          sunHeight = -5;
          sunBrightness = 0;
        }

        // Update sun position and intensity
        sun.position.y = sunHeight;
        sun.position.x = 15 * Math.cos(dayTime * Math.PI * 2);
        sun.position.z = 7 * Math.sin(dayTime * Math.PI * 2) - 5;
        sun.intensity = Math.max(0, sunBrightness);

        // Update sun sphere position to match
        sun.userData.sphere.position.copy(sun.position);
        sun.userData.sphere.position.multiplyScalar(2);

        // Apply sun color change (redder at sunset/sunrise)
        let sunHue = 0.12; // Default yellow
        if (dayTime < 0.1 || (dayTime > 0.4 && dayTime < 0.5)) {
          // Reddish at dawn/dusk
          sunHue = 0.05;
        }
        sun.userData.sphere.material.color.setHSL(sunHue, 1, 0.7);
        sun.userData.sphere.material.opacity = sunBrightness;

        // Update moon position and intensity
        moon.position.y = moonHeight;
        moon.position.x = -15 * Math.cos((dayTime - 0.5) * Math.PI * 2);
        moon.position.z = -7 * Math.sin((dayTime - 0.5) * Math.PI * 2) - 5;
        moon.intensity = Math.max(0, moonBrightness);

        // Update moon sphere position to match
        moon.userData.sphere.position.copy(moon.position);
        moon.userData.sphere.position.multiplyScalar(2);

        // Update stars visibility
        const starsVisible =
          dayTime > 0.5
            ? Math.min(1, (dayTime - 0.5) * 4) // Fade in after sunset
            : Math.max(0, 1 - dayTime * 4); // Fade out before sunrise

        stars.forEach((starField) => {
          starField.material.opacity = starsVisible * 0.8;
        });

        // Update ambient light based on time of day
        let ambientIntensity, ambientColor;

        if (dayTime < 0.2) {
          // Dawn: gradually increasing blue-ish light
          ambientIntensity = (dayTime / 0.2) * 0.5;
          ambientColor = new THREE.Color(0x8888aa);
        } else if (dayTime < 0.4) {
          // Morning: bright with slight yellow tint
          ambientIntensity = 0.5 + ((dayTime - 0.2) / 0.2) * 0.3;
          ambientColor = new THREE.Color(0xffffaa);
        } else if (dayTime < 0.5) {
          // Sunset: orange glow, decreasing
          ambientIntensity = 0.8 - ((dayTime - 0.4) / 0.1) * 0.5;
          ambientColor = new THREE.Color(0xff9955);
        } else if (dayTime < 0.7) {
          // Early night: deep blue, minimal light
          ambientIntensity = 0.3 - ((dayTime - 0.5) / 0.2) * 0.2;
          ambientColor = new THREE.Color(0x334466);
        } else {
          // Late night: very dark blue
          ambientIntensity = 0.1;
          ambientColor = new THREE.Color(0x222244);
        }

        // Find or create the ambient light
        if (!window.ambientLight) {
          window.ambientLight = new THREE.AmbientLight(
            0xffffff,
            ambientIntensity,
          );
          scene.add(window.ambientLight);
        } else {
          window.ambientLight.intensity = ambientIntensity;
          window.ambientLight.color = ambientColor;
        }

        // Update fog and background color
        let fogColor;
        if (dayTime < 0.2) {
          // Dawn: blue to light pink
          fogColor = new THREE.Color(0x8888cc).lerp(
            new THREE.Color(0xffccbb),
            dayTime / 0.2,
          );
        } else if (dayTime < 0.4) {
          // Day: light blue sky
          fogColor = new THREE.Color(0x88aaff);
        } else if (dayTime < 0.5) {
          // Sunset: orange to red
          fogColor = new THREE.Color(0xffaa88).lerp(
            new THREE.Color(0xaa5533),
            (dayTime - 0.4) / 0.1,
          );
        } else if (dayTime < 0.7) {
          // Early night: dark blue
          fogColor = new THREE.Color(0x223366);
        } else {
          // Night: very dark blue
          fogColor = new THREE.Color(0x111133);
        }

        scene.fog.color = fogColor;
        renderer.setClearColor(fogColor);
      }

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);

        // Update the day-night cycle
        updateDayNightCycle();

        // Update floating objects
        updateFloatingObjects();

        // Add additional lighting effects for the player sphere to enhance 3D appearance
        if (player) {
          // Make the player sphere slightly pulsate to enhance 3D effect
          const pulseFactor = 1 + Math.sin(Date.now() * 0.003) * 0.03;
          player.scale.set(pulseFactor, pulseFactor, pulseFactor);
        }

        renderer.render(scene, camera);
      }

      // Start the game
      init();
    </script>
  </body>
</html>
